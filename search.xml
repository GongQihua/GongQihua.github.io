<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2D Game Kit</title>
    <url>/2024/03/18/2D_Game_Kit/</url>
    <content><![CDATA[<h2 id="2D-Game-Kit"><a href="#2D-Game-Kit" class="headerlink" title="2D Game Kit"></a>2D Game Kit</h2><p>2D is a collection of mechanics, tools, systems and assets to hook up gameplay without writing any code. To show how these elements can be used we’ve also created a game example using these systems.<span id="more"></span></p>
<p>官方链接：<a href="https://learn.unity.com/project/2d-game-kit">https://learn.unity.com/project/2d-game-kit</a></p>
<p>资源地址：<a href="https://assetstore.unity.com/packages/templates/tutorials/2d-game-kit-107098">https://assetstore.unity.com/packages/templates/tutorials/2d-game-kit-107098</a></p>
<p>2D 横版跳跃的新手包，主要是教你全局设计2D内容，脚本都是配置好的，往上拖资源和控件就行。这里多设计到一个tile map编辑，但是tilemap里的组件是帮你写好的，主要是体验</p>
<p>主要有两个进阶内容，但都是写好组件，跟着教程走就行</p>
<p>触发式组件（机关开门，甚至物品与怪物的交互）</p>
<p>场景传送（涉及同场景传送和不同场景传送到方法）</p>
<p>内置的脚本可以看一下</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>U3D</tag>
      </tags>
  </entry>
  <entry>
    <title>CreatorKit-FPS</title>
    <url>/2024/03/11/CreatorKit-FPS/</url>
    <content><![CDATA[<h1 id="Unity3D项目初识"><a href="#Unity3D项目初识" class="headerlink" title="Unity3D项目初识"></a>Unity3D项目初识</h1><p>与Playground类似，本项目作为Unity 3D项目的入门，是官方教程的一部分<span id="more"></span></p>
<p>官方教程链接：<a href="https://learn.unity.com/project/creator-kit-fps">https://learn.unity.com/project/creator-kit-fps</a></p>
<p>项目载入地址：<a href="https://assetstore.unity.com/packages/templates/tutorials/unity-learn-creator-kit-fps-urp-149310">https://assetstore.unity.com/packages/templates/tutorials/unity-learn-creator-kit-fps-urp-149310</a></p>
<p>创立一个3D空模版，直接assert store import就能开始了</p>
<p>是一个初级的3D项目，让我们熟悉unity3D编辑器的应用，和控件的使用</p>
<p>跟随教程一步步往下就行，主要体验过程</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>U3D</tag>
      </tags>
  </entry>
  <entry>
    <title>CreatorKit Beginner Code</title>
    <url>/2024/03/12/CreatorKit_BeginnerCode/</url>
    <content><![CDATA[<h1 id="Unity脚本设计入门"><a href="#Unity脚本设计入门" class="headerlink" title="Unity脚本设计入门"></a>Unity脚本设计入门</h1><p>本篇是unity游戏中，C#脚本编辑的初体验<span id="more"></span></p>
<p>依旧是跟随官方教程</p>
<p>链接：<a href="https://learn.unity.com/project/creator-kit-beginner-code">https://learn.unity.com/project/creator-kit-beginner-code</a></p>
<p>导入：<a href="https://assetstore.unity.com/packages/templates/tutorials/creator-kit-beginner-code-urp-151986">https://assetstore.unity.com/packages/templates/tutorials/creator-kit-beginner-code-urp-151986</a></p>
<p>记得创建3D URP模版，不然运行有bug</p>
<p>基本就是C#的标准结构，space，class，function，然后套官方函数，比如读属性，或者位置角度之类的，很简单。</p>
<p>游戏挺有意思的，arpg，可以自己试着加一点获胜条件啥的玩一玩</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>U3D</tag>
      </tags>
  </entry>
  <entry>
    <title>Ruby&#39;s Adventure 2D Beginner</title>
    <url>/2024/04/09/Ruby_Adventure_2D_Beginner/</url>
    <content><![CDATA[<h1 id="Ruby’s-Adventure-2D-Beginner"><a href="#Ruby’s-Adventure-2D-Beginner" class="headerlink" title="Ruby’s Adventure: 2D Beginner"></a>Ruby’s Adventure: 2D Beginner</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>官方的一个非常好的2D教程，涉及：</p>
<p>使用 2D 资源</p>
<p>2D RPG 游戏制作流程</p>
<p>创建并控制角色（使用脚本代码）</p>
<p>使用瓦片地图创建世界</p>
<p>设置动态精灵，角色动画</p>
<p>一些简单特效（粒子效果），UI系统和2D声音系统<span id="more"></span></p>
<p>官方地址：<a href="https://learn.unity.com/project/ruby-s-2d-rpg?uv=2020.3">https://learn.unity.com/project/ruby-s-2d-rpg?uv=2020.3</a></p>
<p>Assert store：<a href="https://assetstore.unity.com/packages/templates/tutorials/unity-learn-2d-beginner-complete-project-urp-140253">https://assetstore.unity.com/packages/templates/tutorials/unity-learn-2d-beginner-complete-project-urp-140253</a></p>
<h2 id="创建并控制角色"><a href="#创建并控制角色" class="headerlink" title="创建并控制角色"></a>创建并控制角色</h2><p>png图像跟着教程往unity拖，unity会自动转格式</p>
<h3 id="移动角色"><a href="#移动角色" class="headerlink" title="移动角色"></a>移动角色</h3><p>Unity 中，通过游戏对象的 Transform 组件，可以获取该对象在场景中的位置 Position，并通过更改 Transform 组件 Position 的值，可以更改其位置。</p>
<h3 id="移动脚本"><a href="#移动脚本" class="headerlink" title="移动脚本"></a>移动脚本</h3><p>在 Update 方法中，更改 Ruby 角色位置</p>
<p>Unity 在每帧执行 Update 内的代码，为了形成动感，游戏（就像电影一样）是高速显示的静止图像。在游戏中通常会在一秒内显示 30 或 60 张图像。其中的一张图像称为一帧。</p>
<p>在此 Update 函数中，你可以编写想要在游戏中连续发生的任何操作（例如，读取玩家的输入、移动游戏对象或计算经过的时间）。</p>
<h4 id="Vector2-二维向量"><a href="#Vector2-二维向量" class="headerlink" title="Vector2 二维向量"></a>Vector2 二维向量</h4><p>在脚本中，Vector 向量&#x2F;矢量指的是带方向的线段</p>
<p>在 Unity 中，Transform 值使用 x 表示水平位置，使用 y 表示垂直位置，使用 z 表示深度。这 3 个数值组成一个坐标。由于此游戏是 2D 游戏，你无需存储 z 轴位置，因此你可以在此处使用 Vector2 来仅存储 x 和 y 位置。</p>
<p>Transform 中 position 的类型，也是 Vector2</p>
<h3 id="控制角色"><a href="#控制角色" class="headerlink" title="控制角色"></a>控制角色</h3><p>控制方式：电脑或主机的输入设备</p>
<p>在 Unity 项目设置中，可以通过 Input Manager 进行默认的游戏输入控制设置 Edit &gt; Project Settings &gt; Input</p>
<p>使用Input类来读取传统游戏输入中设置的轴&#x2F;鼠标&#x2F;按键，以及访问移动设备上的多点触控&#x2F;加速度计数据。若要使用输入来进行任何类型的移动行为，请使用 Input.GetAxis。 它为您提供平滑且可配置的输入 - 可以映射到键盘、游戏杆或鼠标。 请将 Input.GetButton 仅用于事件等操作。不要将它用于移动操作。Input.GetAxis 将使脚本代码更简洁。</p>
<h3 id="时间和帧率"><a href="#时间和帧率" class="headerlink" title="时间和帧率"></a>时间和帧率</h3><p>当前的代码中，帧数越高，同一时间内，执行 Update 的次数越多，角色移动速度越快。</p>
<p>如果游戏以每秒 60 帧的速度运行，那么 Ruby 将移动 0.1 _ 60，因此每秒移动 6 个单位。但是，如果游戏以每秒 10 帧的速度运行，就像刚刚让游戏运行的那样，那么 Ruby 仅移动 0.1 _ 10，因此每秒移动 1 个单位！</p>
<p>如果一个玩家的计算机非常陈旧，只能以每秒 30 帧的速度运行游戏，而另一个玩家的计算机能以每秒 120 帧的速度运行游戏，那么这两个玩家的主角的移动速度会有很大差异。这样就会使游戏的难易程度提高或降低，具体取决于运行游戏的计算机。</p>
<p>而帧数是由硬件水平影响的（越好越高），不同电脑中，会导致游戏效果完全不同</p>
<p>可以锁帧，但硬件能达到的情况下（显卡、显示器），锁帧会降低画面效果。</p>
<p>要解决此问题，你需要以单位&#x2F;秒来表示 Ruby 的移动速度，而不是采用单位&#x2F;帧（目前采用此设置）。</p>
<p>为此，你需要通过将移动速度乘以 Unity 渲染一帧所需的时间来更改移动速度。如果游戏以每秒 10 帧的速度运行，则每帧耗时 0.1 秒。如果游戏以每秒 60 帧的速度运行，则每帧耗时 0.017 秒。如果将移动速度乘以该时间值，则移动速度将以秒表示。</p>
<p>Time.deltaTime 每帧的时间间隔，float 类型</p>
<p>一般将这个值，用在 Update 方法中，乘以移动的距离（或角度），用来获取恒定（不同硬件水平的电脑间）的速度</p>
<h2 id="Tilemap-瓦片地图系统"><a href="#Tilemap-瓦片地图系统" class="headerlink" title="Tilemap 瓦片地图系统"></a>Tilemap 瓦片地图系统</h2><p>Tilemap 是 2D 游戏中，用来构建世界的工具，这个工具使用技术的好坏，直接影响到你制作 2D 游戏时的工作量</p>
<p>瓦片地图组件，是一个存储和操作 Tile 资源的系统，用来创建 2D 关卡。</p>
<p>该系统还可以将所需信息通过所包含的 Tiles 传输到其他相关组件，例如 Tilemap Renderer 和 Tilemap Collider 2D。</p>
<p>创建瓦片地图时，Grid 组件自动作为瓦片地图的父级，并在将瓦片布置到瓦片地图上时作为参照</p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>素材相关：</p>
<ul>
<li>Sprite(精灵)：纹理的容器。大型纹理图集可以转换为精灵图集(Sprite Sheet)</li>
<li>Tile(瓦片)：包含一个精灵，以及二个属性，颜色和碰撞体类型。使用瓦片就像在画布上画画一样，画画时可以设置一些颜色和属性</li>
</ul>
<p>工具相关：</p>
<ul>
<li>Tile Palette(瓦片调色板)：当你在画布(Canvas)上画画时，会需要一个位置来保存绘画的结果。类似地，调色板(Palette)的功能就是保存瓦片，将它们绘制到网格上</li>
<li>Brush(笔刷)：用于将画好的东西绘制到画布上。使用 Tilemap 时，可以在多个笔刷中任意选择，绘制出线条、方块等各种形状</li>
</ul>
<p>组件相关：</p>
<ul>
<li>Tilemap（瓦片地图）：类似 Photoshop 中的图层，我们可以在 Tilemap 上画上 Tile</li>
<li>Grid(网格)：用于控制网格属性的组件。Tilemap 是 Grid 的子对象。Grid 类似于 UI Canvas(UI 画布)。</li>
<li>Tilemap Renderer(瓦片地图渲染器)：是 Tilemap 游戏对象的一部分,用于控制 Tile 在 Tilemap 上的渲染，控制诸如排序、材质和遮罩等。</li>
</ul>
<p>分类</p>
<ul>
<li>Rectangler 矩形瓦片地图</li>
<li>Hexagonal 六边形瓦片地图：除常规瓦片地图外，Unity 还提供 Hexagonal Point Top Tilemap 和 Hexagonal Flat Top Tilemap 瓦片地图。六角形瓦片通常用于战略类桌面游戏，因为它们的中心与边上的任何点之间具有一致的距离，并且相邻的瓦片总是共享边。因此，这些瓦片非常适合构建几乎任何类型的大型游戏区域，并让玩家做出关于移动和定位的战术决策。</li>
</ul>
<h3 id="瓦片和使用流程"><a href="#瓦片和使用流程" class="headerlink" title="瓦片和使用流程"></a>瓦片和使用流程</h3><p><strong>瓦片</strong>是排列在<strong>瓦片地图</strong>上的<strong>资源</strong>，用于构建 2D 环境。每个瓦片引用一个选定的<strong>精灵</strong>，然后在瓦片地图网格上的瓦片位置处渲染该精灵。</p>
<ol>
<li>预处理 sprite 资源：将图片资源拖拽到 project 中，生成 sprite；然后一般需要进行切割 slice ，将其配置成需要的各个 tile;</li>
<li>创建要在其上绘制瓦片的瓦片地图。此过程中还会自动创建 Grid 游戏对象作为瓦片地图的父级。</li>
<li>直接创建瓦片资源，或者通过将用作瓦片素材的精灵带入 Tile Palette 窗口自动生成瓦片。</li>
<li>创建一个包含<strong>瓦片资源</strong>的 Tile Palette，并使用各种笔刷来绘制到<strong>瓦片地图</strong>上。</li>
<li>可以将 Tilemap Collider 2D 组件连接到瓦片地图以便使瓦片地图与 Physics2D 交互。</li>
</ol>
<p>一般 Tilemap 创建三个，分别为:</p>
<ul>
<li>background(地图背景)</li>
<li>bound(边界)</li>
<li>foreground(前景，主要是地形)</li>
</ul>
<h3 id="场景排序"><a href="#场景排序" class="headerlink" title="场景排序"></a>场景排序</h3><p>透视图指的是有深度、距离感的图，一般要三维中的深度轴来表现场景的深度，而二维游戏中没有这个深度，只能通过前后来仿造深度效果，称为“伪透视图”</p>
<p>先前通过调整瓦片的 Order in Layer 属性来解决了瓦片地图的排序问题，但并非总是希望一个游戏对象在另一个游戏对象之上，比如，在同一个瓦片地图中，玩家角色在一个物体之前（比如一棵树）时，应该是玩家遮挡树，而玩家移动到树后时，应该是树遮挡玩家，这就需要“伪造”透视图。</p>
<p>在 2D 游戏中，场景里的 <strong>“前后”</strong> 是由 Y 轴决定的，需要让 Unity 根据游戏对象的 y 坐标来绘制游戏对象</p>
<p>Y 轴 y 坐标值越小，越靠前，应该遮挡 y 坐标值较大的游戏对象，也就是 y 坐标较小的游戏对象后绘制，就会位于上层</p>
<p>每个 Sprite 都有一个轴心（中心点），Unity 根据 pivot 对 sprite 进行定位，这个 pivot 可以在 sprite editor 中调整，可以将其设置到 sprite 上任意位置</p>
<p>在 2D Rpg 游戏场景中的游戏对象，如果想要实现较为真实的 “伪透视” 效果，最好将游戏对象的 sprite 中 pivot 都设置到素材的最下方正中。</p>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>动画剪辑（Animation clip）是动画的基本组成部分，包含某些对象应如何随时间改变其位置、旋转或其他属性的相关信息。</p>
<p>动画剪辑一般和不同的状态相挂接，比如“静止状态”挂接站立不移动时的动画、“奔跑状态”挂接跑动的动画剪辑….</p>
<p>Animator Controller 用来控制不同状态下动画的播放，以及状态间的转换</p>
<p>所有这些部分（动画剪辑、Animator Controller 和 Avatar）都通过 Animator 组件一起附加到某个游戏对象上。</p>
<p>Animator 分为两个部分，左侧是 Layers 和 Parameters，右侧是动画状态机 (Animation State Machine)：</p>
<ul>
<li>第 1 部分：Layers 和 Parameters<br>Layers 可用于 3D 动画，因为你可以将动画用于角色的不同部分。<br>Parameters 由我们的脚本用来向 Controller 提供信息。</li>
<li>第 2 部分：动画状态机<br>动画状态机以图形方式显示动画的所有状态以及如何从一段动画过渡到另一段动画。</li>
</ul>
<p>混合树 (Blend Tree)，这种混合树允许你根据参数来混合多段动画。</p>
<p>Animator 是动画组件，可以理解为一个用来处理动画的功能型容器，所有和动画相关的部分（动画剪辑、Animator Controller 和 Avatar）都通过 Animator 组件一起附加到某个游戏对象上。</p>
<h2 id="UI界面"><a href="#UI界面" class="headerlink" title="UI界面"></a>UI界面</h2><p>Unity 用户界面 (Unity UI) 软件包（也称为 uGUI）是一个较旧的、基于游戏对象的 UI 系统，您可以使用它为游戏和应用程序开发运行时 UI。在 Unity UI 中，即可使用组件和 Game 视图来排列和定位用户界面并设置其样式。它支持高级渲染和文本功能。</p>
<p>使用步骤</p>
<ol>
<li>创建 画布 Canves</li>
<li>在 画布 Canves 中添加 UI 组件（文本、文本框、按钮等等）</li>
<li>设置好布局、动画，以及摄像机、特效等</li>
<li>需要的话，再添加交互事件</li>
</ol>
<h3 id="UGUI-基础"><a href="#UGUI-基础" class="headerlink" title="UGUI 基础"></a>UGUI 基础</h3><p><strong>Rect Transform 矩形变换</strong></p>
<p>矩形变换像常规变换一样具有位置，旋转和比例，但它还具有宽度和高度表示矩形的尺寸。</p>
<p><strong>Pivot 枢轴（轴心）</strong></p>
<p>旋转、大小和缩放修改都是围绕轴心进行的，因此轴心的位置会影响旋转、大小调整或缩放的结果。</p>
<p><strong>Anchors 锚点</strong></p>
<p>锚点在场景视图中显示为四个小三角形手柄（四叶花）。每个叶子位置对应矩形的四个顶点。当描点随父对象变换时，矩形的顶点与对应的锚点相对位置必须保持不变。</p>
<p>例如，子项可以锚定到父项的中心，或锚定到一个角。</p>
<p>通过锚定还可以让子项随父项的宽度或高度一起拉伸。矩形的每个角与其对应的锚点都有一个固定的偏移，即矩形的左上角与左上角锚点有一个固定的偏移，以此类推。因此，矩形的不同角可以锚定到父矩形中的不同点。</p>
<p><strong>遮罩</strong></p>
<p>两个图像，一个是原图像，一个是遮罩图像，显示的是原图像，遮罩图像控制原图像的显示范围，只显示背遮罩区域的原图像。</p>
<p>所以可以通过更改遮罩图像的大小，来不失真地显示原图像的部分区域</p>
<p><strong>静态成员</strong></p>
<p>可以使用 static 关键字把类成员定义为静态的。当我们声明一个类成员为静态时，意味着无论有多少个类的对象被创建，只会有一个该静态成员，并且被所有类对象所共享。</p>
<h2 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h2><p>为了模拟位置的影响，Unity 要求声音源来自附加到对象的 <strong>音频源</strong> Audio Source。然后，发出的声音由附加到另一个对象（通常是主摄像机）上的 <strong>音频监听器</strong> Audio Listener 拾取。Unity 然后可以模拟音频源与监听器物体之间的距离和位置的影响，并相应地播放给用户。此外还使用源对象和监听器对象的相对速度来模拟多普勒效应以增加真实感。</p>
<p>Unity 混音器 (Audio Mixer) 允许您混合各种音频源，对音频源应用效果，以及执行母带制作 (mastering)。</p>
<p>Unity 可以导入大多数标准音频文件格式，音频文件在 Unity 中 <strong>音频剪辑</strong> Audio Clip</p>
<p>AIFF、WAV、MP3 和 Ogg 等格式的音频文件，只需要将文件拖入 Project 面板即可。</p>
<h3 id="音频剪辑-Audio-Clip"><a href="#音频剪辑-Audio-Clip" class="headerlink" title="音频剪辑 Audio Clip"></a>音频剪辑 Audio Clip</h3><p>音频剪辑 Audio Clip 就是在 Unity 中实际发声的音频文件</p>
<p>Unity 支持单声道、立体声和多声道音频资源（最多八声道）</p>
<p>Unity 可以导入的音频文件格式包括：.aif、.wav、.mp3 和 .ogg。Unity 还能够导入 .xm、.mod、.it 和 .s3m 格式的音轨模块。</p>
<h3 id="音频源-Audio-Source"><a href="#音频源-Audio-Source" class="headerlink" title="音频源 Audio Source"></a>音频源 Audio Source</h3><p>音频源 (Audio Source) 在场景中播放 音频剪辑 Audio Clip。</p>
<p>如果不为音频源指定<strong>音频剪辑</strong>，音频源不起作用。</p>
<p>音频源就像一个控制器，用于启动和停止该剪辑音源的播放，以及修改其他音频属性</p>
<p>核心属性：</p>
<ul>
<li><p>Audio Clip： 将要播放的声音剪辑文件。</p>
</li>
<li><p>Output： 默认情况下，剪辑将直接输出到场景中的音频监听器 (Audio Listener)</p>
</li>
<li><p>Mute： 如果启用此选项，则为静音</p>
</li>
<li><p>Play On Awake： 如果启用此选项，声音将在场景启动时开始播放。如果禁用此选项，需要通过脚本使用 Play() 命令启用播放</p>
</li>
<li><p>Loop： 启用此选项可在<strong>音频剪辑</strong>结束后循环播放</p>
</li>
<li><p>Priority： 从场景中存在的所有音频源中确定此音频源的优先级。（Priority 值为 0 表示优先级最高。值为 256， 表示优先级最低。默认值为 128）</p>
</li>
<li><p>Volume： 设置声音的大小，但请注意，除了这个属性外，玩家听到的声音，与离<strong>音频监听器</strong>的距离成正比，以米为世界单位</p>
</li>
<li><p>Spatial Blend： 设置 3D 引擎对音频源的影响程度。</p>
</li>
</ul>
<h3 id="音频监听器-Audio-Listener"><a href="#音频监听器-Audio-Listener" class="headerlink" title="音频监听器 Audio Listener"></a>音频监听器 Audio Listener</h3><p>音频监听器 (Audio Listener) 充当类似于麦克风的设备。它接收来自场景中任何给定音频源的输入，并通过计算机扬声器播放声音。对于大多数应用程序，最有意义的是将监听器附加到主摄像机。</p>
<p>音频监听器与音频源配合使用，可让您为游戏营造听觉体验。当音频监听器连接到场景中的<strong>游戏对象</strong>时，任何足够接近监听器的源都将被拾取并输出到计算机的扬声器。每个场景只能有 1 个音频监听器才能正常工作。</p>
<p>通常，应该将音频监听器连接到主摄像机或代表玩家的游戏对象。</p>
<p>注意：</p>
<ul>
<li>每个场景只能有一个音频监听器</li>
</ul>
<h3 id="Unity-中播放声音的基本使用步骤"><a href="#Unity-中播放声音的基本使用步骤" class="headerlink" title="Unity 中播放声音的基本使用步骤"></a>Unity 中播放声音的基本使用步骤</h3><p><strong>通过 Unity 面板可视化控制</strong></p>
<ol>
<li>为当前场景配置 Audio Listener，可以连接到主摄像机，或玩家游戏对象（第一人称或第三人称追尾游戏）；</li>
<li>将音频文件素材拖拽入 project 窗口，生成 音频剪辑 Audio Clip</li>
<li>创建空游戏对象，并为其添加 音频源 Audio Source 组件，用来配置管理 Audio Clip</li>
</ol>
<p><strong>使用代码</strong></p>
<ul>
<li>方式一（一对一）：为游戏中每个要播放声音的游戏对象都配置音频源组件，并绑定该音频源的音频剪辑，通过代码来控制该声音源组件来播放其中的音频剪辑；</li>
<li>方式二（一对多）：通过一个音频源，用代码控制播放多个不同的音频剪辑，使用 AudioSource 类对象的一个名为 PlayOneShot 的函数来实现</li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>U3D</tag>
      </tags>
  </entry>
  <entry>
    <title>生成在线URL</title>
    <url>/2024/02/27/picture-URL/</url>
    <content><![CDATA[<h1 id="本地图片生成在线URL"><a href="#本地图片生成在线URL" class="headerlink" title="本地图片生成在线URL"></a>本地图片生成在线URL</h1><p>方法就是用图床，找个在线图床网站，上传图片<span id="more"></span></p>
<p>可用网址：<a href="https://sm.ms/">https://sm.ms/</a></p>
<p>注册，上传图片，把网站给的Image URL复制下来就行</p>
<h1 id="PDF生成-URL"><a href="#PDF生成-URL" class="headerlink" title="PDF生成 URL"></a>PDF生成 URL</h1><p>方法类似，找个pdf url工具，上传，生成</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>URL</tag>
      </tags>
  </entry>
  <entry>
    <title>系统代理设置</title>
    <url>/2024/02/27/proxy-setting/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在git同步的时候，不是连不上github,就是连接超时，贼不习惯。</p>
<p>网上搜了一圈乱七八糟的解决方案，很多都是要改源文件的，感觉根本不用那么麻烦就自己摸索了一下，简便的设置方法<span id="more"></span></p>
<p>首先，代理设置全局(global)，全局，全局，重要的事说三遍。因为这基本解决了win上的git问题，但也有例外。</p>
<p>首先，修改git的proxy和修改terminal的proxy不一样，分情况说：</p>
<h2 id="Win"><a href="#Win" class="headerlink" title="Win"></a>Win</h2><h3 id="cmd-powershell修改proxy："><a href="#cmd-powershell修改proxy：" class="headerlink" title="cmd, powershell修改proxy："></a>cmd, powershell修改proxy：</h3><p>cmd：打开输入set http_proxy&#x3D;<a href="http://127.0.0.1:7890/">http://127.0.0.1:7890</a> 和 set https_proxy&#x3D;<a href="http://127.0.0.1:7890，7890是你的代理端口（proxy">http://127.0.0.1:7890，7890是你的代理端口（proxy</a> port），自己替换。</p>
<p>Powershell：输入 $Env:http_proxy&#x3D;”<a href="http://127.0.0.1:7890/">http://127.0.0.1:7890</a>“ 和 $Env:https_proxy&#x3D;”<a href="http://127.0.0.1:7890"，代理端口同上。">http://127.0.0.1:7890&quot;，代理端口同上。</a></p>
<p>clashX有一键复制，点port后的那个命令行小按键。但是是一次性的，每次重开窗口都要再打一遍，但我觉得比改源文件好，因为会影响电脑正常使用，还要去改回来。</p>
<h3 id="Vscode-JetBrains"><a href="#Vscode-JetBrains" class="headerlink" title="Vscode &amp; JetBrains"></a>Vscode &amp; JetBrains</h3><p>设置CMD和prompt没用，vscode里打开终端设置也没用，但是有个更便捷的方法：</p>
<p>文件-首选项-设置-应用程序-代理服务器-proxy，代理地址打进去。</p>
<p>JetBrains基本跟vs一样，找http proxy设置，往里一输就完了。</p>
<h2 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h2><p>首先还是全局，但mac是伪全局。</p>
<h3 id="终端："><a href="#终端：" class="headerlink" title="终端："></a>终端：</h3><p>猫猫头右键，有个终端代理模式（之类的)</p>
<p>输入terminal： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890</span><br></pre></td></tr></table></figure>

<p>设置完了，什么brew，nvm，npm全能跑，不香吗。</p>
<p>其他代理：同win cmd的方法，务必开全局，然后复制终端代理的代码。</p>
<h2 id="直接修改git-proxy："><a href="#直接修改git-proxy：" class="headerlink" title="直接修改git proxy："></a>直接修改git proxy：</h2><p>各系统通用，但仅仅让git跑起来，例如mac上的brew，conda之类的，如果被墙了照样没用</p>
<p>终端输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global https.proxy http://127.0.0.1:7890</span><br><span class="line">git config --global https.proxy https://127.0.0.1:7890</span><br></pre></td></tr></table></figure>

<p>（ps：实在不行，github desktop解决一切问题，代理不开全局都能活）</p>
]]></content>
      <categories>
        <category>Setup</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Playground</title>
    <url>/2024/03/09/unity-Playground/</url>
    <content><![CDATA[<h1 id="Unity-练手第一个游戏"><a href="#Unity-练手第一个游戏" class="headerlink" title="Unity 练手第一个游戏"></a>Unity 练手第一个游戏</h1><p>Unity2D的初识项目，新手入门第一次项目体验。<span id="more"></span></p>
<p>Unity官方网址： <a href="https://learn.unity.com/project/unity-playground">https://learn.unity.com/project/unity-playground</a></p>
<p>主要流程还是要看官方教程，作为熟悉unity第一个上手项目，官方手把手教程，按步骤一步步来</p>
<p>资源载入： <a href="https://assetstore.unity.com/packages/templates/tutorials/unity-learn-playground-urp-109917">https://assetstore.unity.com/packages/templates/tutorials/unity-learn-playground-urp-109917</a></p>
<p>按上一篇教程，创建2D空模版，package manager import</p>
<p>这个教程里主要是2D项目的入门介绍，脚本都已经写好了，主要是熟悉控件和unity2D的使用</p>
<p>里面还有很多初级的游戏模版，可以直接运行，控件脚本可以打开看一看。</p>
<p>Playground的项目里还有好几个example，可以都运行一下，启发启发灵感。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>U3D</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity，启动!</title>
    <url>/2024/03/06/unity-begin/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>万事开头难，中间难，结尾难</p>
<p>世上无难事，只要肯放弃</p>
</blockquote>
<p>本篇记录unity入门和常用资源内容链接</p>
<p>官方教程内容是最好的内容！<span id="more"></span></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol>
<li><p>C# 环境配置</p>
<p>win专属：visual studio一步到位，选C# 桌面应用，unity扩展这两项即可。</p>
<p>或者：</p>
<p>下载dotnet（官网或者brew），vscode扩展，rider。</p>
<p>mac要多下一个mono框架</p>
</li>
<li><p>unity配置</p>
<p>官网下载unity hub，hub安装选择unity版本</p>
<p>建议不要默认，进去自选，最小安装，以后可以加配（加了不能删，什么鬼啊！）</p>
<p>设置unity使用的编辑器，默认win和mac都是vs（mac的vs都快GG了）</p>
<p>编辑器的unity好用插件，按需求来</p>
</li>
</ol>
<h2 id="官方资源"><a href="#官方资源" class="headerlink" title="官方资源"></a>官方资源</h2><p>建议看英语，并不是中文不好看，而是中文文档是机翻！有些甚至不翻！（都有GPT了，有没有搞错啊）</p>
<p>官网：<a href="https://unity.com/">https://unity.com</a></p>
<p>文档：<a href="https://docs.unity.com/">https://docs.unity.com</a></p>
<p>Unity Learn：<a href="https://learn.unity.com/">https://learn.unity.com</a></p>
<p>Assert Store：<a href="https://assetstore.unity.com/">https://assetstore.unity.com</a></p>
<blockquote>
<p>先在assert store里import，然后hub创建空项目，package manager导入</p>
</blockquote>
<h2 id="软件界面"><a href="#软件界面" class="headerlink" title="软件界面"></a>软件界面</h2><p>软件界面各个按键是操作的基本，看官方文档吧</p>
<p>顺便b站和github都有教程，边做边熟悉，关键是一些画面快速操作的快捷键</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>U3D</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建个人博客</title>
    <url>/2024/02/27/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="个人博客搭建指北"><a href="#个人博客搭建指北" class="headerlink" title="个人博客搭建指北"></a>个人博客搭建指北</h1><p>搭建个人静态博客，Hexo+Next+Github Pages。</p>
<p>平台：macos</p>
<p>本地：nvm，JS一套，Hexo，Next主题</p>
<p>网站：免费github pages，或自己搞个云服务<span id="more"></span></p>
<h1 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h1><ol>
<li><p>Xcode开发工具，带有一些基础环境和git</p>
</li>
<li><p>安装本地NodeJS</p>
<ol>
<li><p>这一步有坑，不要brew安装或者官网的sdk安装，会报错。在安装 Hexo 的过程中出现 <code>EACCES</code> 权限错误，这里不要看网上的建议，<strong>不要</strong> 使用 root、sudo 等方法覆盖权限。会报更大的错！</p>
</li>
<li><p>使用nvm或者nvs部署，这里用的是nvm。</p>
<p>链接：<a href="https://github.com/nvm-sh/nvm">https://github.com/nvm-sh/nvm</a></p>
<p>terminal命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh</span><br></pre></td></tr></table></figure>

<p>下完验证一下</p>
<p><code>nvm -v</code></p>
<p>如果没有，去配一下环境，别看网上一堆，要找mac zsh添加环境</p>
</li>
<li><p>nvm安装node和npm</p>
<p><code>nvm install node</code> 可以指定版本，看一下nvm help</p>
<p>装完验证一下，不行加环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>安装Hexo</p>
<p>精简版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>也可以用完整版安装指令，装完验证，要指定版本的话记得看一下版本对应</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>建站，创立项目文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>可以自定义路径，现在文件夹在主目录下，可以查看</p>
</li>
<li><p>在文件夹安装Next主题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd your-hexo-site</span><br><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>大功告成</p>
</li>
</ol>
<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p>没有什么，是比官方文档更好使的教程！</p>
<p>中文：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a> 英语：<a href="https://hexo.io/docs/index.html">https://hexo.io/docs/index.html</a></p>
<p>创建文章，编辑source下的markdown文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>生成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<p>服务器预览</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>发布</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<h2 id="部署github"><a href="#部署github" class="headerlink" title="部署github"></a>部署github</h2><ol>
<li><p>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改主config.yml配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span><br><span class="line">  branch: [branch]</span><br><span class="line">  message: [message]</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成站点文件并推送至远程库。执行 <code>hexo clean &amp;&amp; hexo deploy</code>。注意，如果是从站，config里把前面的网站URL设置一下</p>
</li>
</ol>
<p><em><strong>GitHub Pages 源存储库的建议限制为1 GB。 有关详细信息，请参阅“关于GitHub 上的大文件” 发布的GitHub Pages 站点不得超过1 GB。 如果花费的时间超过10 分钟，GitHub Pages 部署将超时。</strong></em></p>
<p><em><strong>个人主页只能创建一个，项目主页可以创建多个</strong></em></p>
<h1 id="Next主题"><a href="#Next主题" class="headerlink" title="Next主题"></a>Next主题</h1><p>同给出官方文档链接：</p>
<p><a href="https://theme-next.iissnan.com/">https://theme-next.iissnan.com/</a></p>
<p>似乎是旧版的，新版的我只找到更新日志，但是旧版大多通用</p>
<p><a href="https://theme-next.org/index.html">https://theme-next.org/index.html</a></p>
<p>在config里的修改theme，即可启用主题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<p>剩下的自定义功能还是去看官方文档吧</p>
<hr>
<p>（ps: 第一次用typora写完一个文档，感觉好难用啊，有些本来要用上的html语法都识别不出来，:(，还有格式问题，不如直接vscode编辑，大呼上当)</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity AssetBundle实战</title>
    <url>/2024/06/03/AssetBundle%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="AssetBundle实战（AB打包）"><a href="#AssetBundle实战（AB打包）" class="headerlink" title="AssetBundle实战（AB打包）"></a>AssetBundle实战（AB打包）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>AssetBundle打包实战项目，主要是AssetBundle怎么打包的，怎么加载以及卸载的过场和原理，随便倒了个资源包进来，进行实操。</p>
<p>还有对相关理论问题的一些总结<span id="more"></span></p>
<p>项目地址: <a href="https://github.com/GongQihua">传送门</a>, 演示视频在DEMO文件夹下。</p>
<h2 id="编译器打包工具开发"><a href="#编译器打包工具开发" class="headerlink" title="编译器打包工具开发"></a>编译器打包工具开发</h2><blockquote>
<p>打出的ab资源在工程同级的AssetBundle下</p>
<p>可以无缝切换编辑器和AB加载方式</p>
<p>注意AB模式下，改完资源记得Tools&#x2F;ResBuild一下</p>
<p>支持同步异步等方式</p>
<p>具体的打包配置在BuildSetting.xml里配置即可，具体精细到文件还是文件夹都可以。</p>
</blockquote>
<p>主要工程代码在AssetBundleFramework下，core和editor</p>
<p>现在菜单里创建打包工具，方便使用，大概方法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">region</span> Build MenuItem</span></span><br><span class="line"></span><br><span class="line">        [<span class="meta">MenuItem(<span class="string">&quot;Tools/ResBuild/Windows&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BuildWindows</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">MenuItem(<span class="string">&quot;Tools/ResBuild/Android&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BuildAndroid</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">MenuItem(<span class="string">&quot;Tools/ResBuild/iOS&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BuildIos</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span></span></span><br></pre></td></tr></table></figure>

<p>后面相似的创建就不复述了</p>
<p>core里创建一个文件，Profiler，作为按键等操作的log输出。项目需要的是规范的log输出，记录干了什么，抛出错误，记录时间等等。代码自查吧，算是一个前置工作</p>
<p>再就是打包的基本配置，不同平台需要不同的配置，配置是xml文件，切换配置的函数：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SwitchPlatform</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> platform = PLATFORM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (platform)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;windows&quot;</span>:</span><br><span class="line">            EditorUserBuildSettings.SwitchActiveBuildTarget(BuildTargetGroup.Standalone, BuildTarget.StandaloneWindows64);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;android&quot;</span>:</span><br><span class="line">            EditorUserBuildSettings.SwitchActiveBuildTarget(BuildTargetGroup.Android, BuildTarget.Android);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ios&quot;</span>:</span><br><span class="line">            EditorUserBuildSettings.SwitchActiveBuildTarget(BuildTargetGroup.iOS, BuildTarget.iOS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BuildSetting <span class="title">LoadSetting</span>(<span class="params"><span class="built_in">string</span> settingPath</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    buildSetting = XmlUtility.Read&lt;BuildSetting&gt;(settingPath);</span><br><span class="line">    <span class="keyword">if</span> (buildSetting == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$&quot;Load buildSetting failed,SettingPath:<span class="subst">&#123;settingPath&#125;</span>.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    (buildSetting <span class="keyword">as</span> ISupportInitialize)?.EndInit();</span><br><span class="line"></span><br><span class="line">    buildPath = Path.GetFullPath(buildSetting.buildRoot).Replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (buildPath.Length &gt; <span class="number">0</span> &amp;&amp; buildPath[buildPath.Length - <span class="number">1</span>] != <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buildPath += <span class="string">&quot;/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buildPath += <span class="string">$&quot;<span class="subst">&#123;PLATFORM&#125;</span>/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buildSetting;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动切换：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_IOS</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> PLATFORM = <span class="string">&quot;iOS&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> UNITY_ANDROID</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> PLATFORM = <span class="string">&quot;Android&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> PLATFORM = <span class="string">&quot;Windows&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>建一个BuilderSetting类，里面是序列化，配置xml文件用的，函数有什么处理后缀啊，存储，忽略列表，打包选项等等，核心就是能在主函数里配置这些东西去调用，具体代码自己看</p>
<p>还有一个用来解析xml的类，上面那个是操作文件，这个是解析xml，包括了读取、保存和传出来的方法，文件名XmlUtility，自己看吧</p>
<p>EbundleType枚举文件类型，ab粒度类型</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> EBundleType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 以文件作为ab名字（最小粒度）</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    File,</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 以目录作为ab的名字</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Directory,</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 以最上的</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    All</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有资源类型函数EResourceType，合集写在BuildItem里，还包括资源后缀</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> EResourceType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 在打包设置中分析到的资源</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Direct = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 依赖资源</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Dependency = <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 生成的文件</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    Ganerate = <span class="number">3</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打包流程，就是主函数下的Build，中间过程注释写的很清楚了</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Build</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ms_BuildProfiler.Start();</span><br><span class="line"></span><br><span class="line">    ms_SwitchPlatformProfiler.Start();</span><br><span class="line">    SwitchPlatform();</span><br><span class="line">    ms_SwitchPlatformProfiler.Stop();</span><br><span class="line"></span><br><span class="line">    ms_LoadBuildSettingProfiler.Start();</span><br><span class="line">    buildSetting = LoadSetting(BuildSettingPath);</span><br><span class="line">    ms_LoadBuildSettingProfiler.Stop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//搜集bundle信息</span></span><br><span class="line">    ms_CollectProfiler.Start();</span><br><span class="line">    Dictionary&lt;<span class="built_in">string</span>, List&lt;<span class="built_in">string</span>&gt;&gt; bundleDic = Collect();</span><br><span class="line">    ms_CollectProfiler.Stop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打包assetbundle</span></span><br><span class="line">    ms_BuildBundleProfiler.Start();</span><br><span class="line">    BuildBundle(bundleDic);</span><br><span class="line">    ms_BuildBundleProfiler.Stop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空多余文件</span></span><br><span class="line">    ms_ClearBundleProfiler.Start();</span><br><span class="line">    ClearAssetBundle(buildPath, bundleDic);</span><br><span class="line">    ms_ClearBundleProfiler.Stop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把描述文件打包bundle</span></span><br><span class="line">    ms_BuildManifestBundleProfiler.Start();</span><br><span class="line">    BuildManifest();</span><br><span class="line">    ms_BuildManifestBundleProfiler.Stop();</span><br><span class="line"></span><br><span class="line">    EditorUtility.ClearProgressBar();</span><br><span class="line"></span><br><span class="line">    ms_BuildProfiler.Stop();</span><br><span class="line"></span><br><span class="line">    Debug.Log(<span class="string">$&quot;打包完成<span class="subst">&#123;ms_BuildProfiler&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>，先收集信息，将文件信息收集进主函数的方法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Dictionary&lt;<span class="built_in">string</span>, List&lt;<span class="built_in">string</span>&gt;&gt; Collect()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取所有在打包设置的文件列表</span></span><br><span class="line">    ms_CollectBuildSettingFileProfiler.Start();</span><br><span class="line">    HashSet&lt;<span class="built_in">string</span>&gt; files = buildSetting.Collect();</span><br><span class="line">    ms_CollectBuildSettingFileProfiler.Stop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//搜集所有文件的依赖关系</span></span><br><span class="line">    ms_CollectDependencyProfiler.Start();</span><br><span class="line">    Dictionary&lt;<span class="built_in">string</span>, List&lt;<span class="built_in">string</span>&gt;&gt; dependencyDic = CollectDependency(files);</span><br><span class="line">    ms_CollectDependencyProfiler.Stop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标记所有资源的信息</span></span><br><span class="line">    Dictionary&lt;<span class="built_in">string</span>, EResourceType&gt; assetDic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, EResourceType&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被打包配置分析到的直接设置为Direct</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> url <span class="keyword">in</span> files)</span><br><span class="line">    &#123;</span><br><span class="line">        assetDic.Add(url, EResourceType.Direct);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//依赖的资源标记为Dependency，已经存在的说明是Direct的资源</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> url <span class="keyword">in</span> dependencyDic.Keys)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!assetDic.ContainsKey(url))</span><br><span class="line">        &#123;</span><br><span class="line">            assetDic.Add(url, EResourceType.Dependency);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该字典保存bundle对应的资源集合</span></span><br><span class="line">    ms_CollectBundleProfiler.Start();</span><br><span class="line">    Dictionary&lt;<span class="built_in">string</span>, List&lt;<span class="built_in">string</span>&gt;&gt; bundleDic = CollectBundle(buildSetting, assetDic, dependencyDic);</span><br><span class="line">    ms_CollectBundleProfiler.Stop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成Manifest文件</span></span><br><span class="line">    ms_GenerateManifestProfiler.Start();</span><br><span class="line">    GenerateManifest(assetDic, bundleDic, dependencyDic);</span><br><span class="line">    ms_GenerateManifestProfiler.Stop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bundleDic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面调用的两个函数的功能为收集指定文件集合所有的依赖信息和搜集bundle对应的ab名字，自己看函数吧</p>
<p>Collect最后还需要一个生成Manifest的函数，写在下面了，主要三步，生成资源描述信息，生成bundle描述信息和生成资源依赖描述信息，代码太长，不贴了</p>
<p>信息收集完以后，打包assetbundle</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AssetBundleManifest <span class="title">BuildBundle</span>(<span class="params">Dictionary&lt;<span class="built_in">string</span>, List&lt;<span class="built_in">string</span>&gt;&gt; bundleDic</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> min = ms_BuildBundleProgress.x;</span><br><span class="line">    <span class="built_in">float</span> max = ms_BuildBundleProgress.y;</span><br><span class="line"></span><br><span class="line">    EditorUtility.DisplayProgressBar(<span class="string">$&quot;<span class="subst">&#123;<span class="keyword">nameof</span>(BuildBundle)&#125;</span>&quot;</span>, <span class="string">&quot;打包AssetBundle&quot;</span>, min);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Directory.Exists(buildPath))</span><br><span class="line">        Directory.CreateDirectory(buildPath);</span><br><span class="line"></span><br><span class="line">    AssetBundleManifest manifest = BuildPipeline.BuildAssetBundles(buildPath, GetBuilds(bundleDic), BuildAssetBundleOptions, EditorUserBuildSettings.activeBuildTarget);</span><br><span class="line"></span><br><span class="line">    EditorUtility.DisplayProgressBar(<span class="string">$&quot;<span class="subst">&#123;<span class="keyword">nameof</span>(BuildBundle)&#125;</span>&quot;</span>, <span class="string">&quot;打包AssetBundle&quot;</span>, max);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> manifest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和获取所有需要打包的AssetBundleBuild</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AssetBundleBuild[] <span class="title">GetBuilds</span>(<span class="params">Dictionary&lt;<span class="built_in">string</span>, List&lt;<span class="built_in">string</span>&gt;&gt; bundleTable</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">    AssetBundleBuild[] assetBundleBuilds = <span class="keyword">new</span> AssetBundleBuild[bundleTable.Count];</span><br><span class="line">    <span class="keyword">foreach</span> (KeyValuePair&lt;<span class="built_in">string</span>, List&lt;<span class="built_in">string</span>&gt;&gt; pair <span class="keyword">in</span> bundleTable)</span><br><span class="line">    &#123;</span><br><span class="line">        assetBundleBuilds[index++] = <span class="keyword">new</span> AssetBundleBuild()</span><br><span class="line">        &#123;</span><br><span class="line">            assetBundleName = pair.Key,</span><br><span class="line">            assetNames = pair.Value.ToArray(),</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> assetBundleBuilds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清理多余的AssetBundle</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ClearAssetBundle</span>(<span class="params"><span class="built_in">string</span> path, Dictionary&lt;<span class="built_in">string</span>, List&lt;<span class="built_in">string</span>&gt;&gt; bundleDic</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> min = ms_ClearBundleProgress.x;</span><br><span class="line">    <span class="built_in">float</span> max = ms_ClearBundleProgress.y;</span><br><span class="line"></span><br><span class="line">    EditorUtility.DisplayProgressBar(<span class="string">$&quot;<span class="subst">&#123;<span class="keyword">nameof</span>(ClearAssetBundle)&#125;</span>&quot;</span>, <span class="string">&quot;清除多余的AssetBundle文件&quot;</span>, min);</span><br><span class="line"></span><br><span class="line">    List&lt;<span class="built_in">string</span>&gt; fileList = GetFiles(path, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    HashSet&lt;<span class="built_in">string</span>&gt; fileSet = <span class="keyword">new</span> HashSet&lt;<span class="built_in">string</span>&gt;(fileList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> bundle <span class="keyword">in</span> bundleDic.Keys)</span><br><span class="line">    &#123;</span><br><span class="line">        fileSet.Remove(<span class="string">$&quot;<span class="subst">&#123;path&#125;</span><span class="subst">&#123;bundle&#125;</span>&quot;</span>);</span><br><span class="line">        fileSet.Remove(<span class="string">$&quot;<span class="subst">&#123;path&#125;</span><span class="subst">&#123;bundle&#125;</span><span class="subst">&#123;BUNDLE_MANIFEST_SUFFIX&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fileSet.Remove(<span class="string">$&quot;<span class="subst">&#123;path&#125;</span><span class="subst">&#123;PLATFORM&#125;</span>&quot;</span>);</span><br><span class="line">    fileSet.Remove(<span class="string">$&quot;<span class="subst">&#123;path&#125;</span><span class="subst">&#123;PLATFORM&#125;</span><span class="subst">&#123;BUNDLE_MANIFEST_SUFFIX&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Parallel.ForEach(fileSet, ParallelOptions, File.Delete);</span><br><span class="line"></span><br><span class="line">    EditorUtility.DisplayProgressBar(<span class="string">$&quot;<span class="subst">&#123;<span class="keyword">nameof</span>(ClearAssetBundle)&#125;</span>&quot;</span>, <span class="string">&quot;清除多余的AssetBundle文件&quot;</span>, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，把描述文件打包bundle</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BuildManifest</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> min = ms_BuildManifestProgress.x;</span><br><span class="line">    <span class="built_in">float</span> max = ms_BuildManifestProgress.y;</span><br><span class="line"></span><br><span class="line">    EditorUtility.DisplayProgressBar(<span class="string">$&quot;<span class="subst">&#123;<span class="keyword">nameof</span>(BuildManifest)&#125;</span>&quot;</span>, <span class="string">&quot;将Manifest打包成AssetBundle&quot;</span>, min);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Directory.Exists(TempBuildPath))</span><br><span class="line">        Directory.CreateDirectory(TempBuildPath);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> prefix = Application.dataPath.Replace(<span class="string">&quot;/Assets&quot;</span>, <span class="string">&quot;/&quot;</span>).Replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    AssetBundleBuild manifest = <span class="keyword">new</span> AssetBundleBuild();</span><br><span class="line">    manifest.assetBundleName = <span class="string">$&quot;<span class="subst">&#123;MANIFEST&#125;</span><span class="subst">&#123;BUNDLE_SUFFIX&#125;</span>&quot;</span>;</span><br><span class="line">    manifest.assetNames = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">3</span>]</span><br><span class="line">    &#123;</span><br><span class="line">        ResourcePath_Binary.Replace(prefix,<span class="string">&quot;&quot;</span>),</span><br><span class="line">        BundlePath_Binary.Replace(prefix,<span class="string">&quot;&quot;</span>),</span><br><span class="line">        DependencyPath_Binary.Replace(prefix,<span class="string">&quot;&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    EditorUtility.DisplayProgressBar(<span class="string">$&quot;<span class="subst">&#123;<span class="keyword">nameof</span>(BuildManifest)&#125;</span>&quot;</span>, <span class="string">&quot;将Manifest打包成AssetBundle&quot;</span>, min + (max - min) * <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">    AssetBundleManifest assetBundleManifest = BuildPipeline.BuildAssetBundles(TempBuildPath, <span class="keyword">new</span> AssetBundleBuild[] &#123; manifest &#125;, BuildAssetBundleOptions, EditorUserBuildSettings.activeBuildTarget);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把文件copy到build目录</span></span><br><span class="line">    <span class="keyword">if</span> (assetBundleManifest)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> manifestFile = <span class="string">$&quot;<span class="subst">&#123;TempBuildPath&#125;</span>/<span class="subst">&#123;MANIFEST&#125;</span><span class="subst">&#123;BUNDLE_SUFFIX&#125;</span>&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> target = <span class="string">$&quot;<span class="subst">&#123;buildPath&#125;</span>/<span class="subst">&#123;MANIFEST&#125;</span><span class="subst">&#123;BUNDLE_SUFFIX&#125;</span>&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (File.Exists(manifestFile))</span><br><span class="line">        &#123;</span><br><span class="line">            File.Copy(manifestFile, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除临时目录</span></span><br><span class="line">    <span class="keyword">if</span> (Directory.Exists(TempBuildPath))</span><br><span class="line">        Directory.Delete(TempBuildPath, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    EditorUtility.DisplayProgressBar(<span class="string">$&quot;<span class="subst">&#123;<span class="keyword">nameof</span>(BuildManifest)&#125;</span>&quot;</span>, <span class="string">&quot;将Manifest打包成AssetBundle&quot;</span>, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把buildsetting里的获取BundleName的函数补一下，现在就已经能跑了，会在项目外面生成几个.ab的文件，那些就是打包的文件。</p>
<p>接着要考虑怎么加载的问题，写在Demo下的Test_Callback里</p>
<p>主要是这个函数，剩下都是找文件名和拼接字符串的</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Initialize</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ResourceManager.instance.LoadWithCallback(<span class="string">&quot;Assets/AssetBundle/UI/UIRoot.prefab&quot;</span>, <span class="literal">true</span>, uiRootResource =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        uiRootResource.Instantiate();</span><br><span class="line"></span><br><span class="line">        Transform uiParent = GameObject.Find(<span class="string">&quot;Canvas&quot;</span>).transform;</span><br><span class="line"></span><br><span class="line">        ResourceManager.instance.LoadWithCallback(<span class="string">&quot;Assets/AssetBundle/UI/TestUI.prefab&quot;</span>, <span class="literal">true</span>, testUIResource =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            testUIResource.Instantiate(uiParent, <span class="literal">false</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要达成加载的目的，也就引出了下一个函数，就是我们需要一个ResourceManager来管理这些加载项，在Core里的Resource下，里面有ResourceManager</p>
<p>代码太长不贴了，大概就是读取资源信息，读取bundle信息，读取资源依赖信息，加载这些信息，和最后释放这些信息</p>
<p>bundle加载，在Bundle文件夹下，同步异步加载资源，Demo里有个Test_Callback，会调用加载</p>
<p>在lateupdate里写卸载函数时要注意，不断轮询确保及时卸载不用的Ab</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LateUpdate</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_NeedUnloadList.Count == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (m_NeedUnloadList.Count &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ABundle bundle = m_NeedUnloadList.First.Value;</span><br><span class="line">                m_NeedUnloadList.RemoveFirst();</span><br><span class="line">                <span class="keyword">if</span> (bundle == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                m_BundleDic.Remove(bundle.url);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!bundle.done &amp;&amp; bundle <span class="keyword">is</span> BundleAsync)</span><br><span class="line">                &#123;</span><br><span class="line">                    BundleAsync bundleAsync = bundle <span class="keyword">as</span> BundleAsync;</span><br><span class="line">                    <span class="keyword">if</span> (m_AsyncList.Contains(bundleAsync))</span><br><span class="line">                        m_AsyncList.Remove(bundleAsync);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                bundle.UnLoad();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//依赖引用-1</span></span><br><span class="line">                <span class="keyword">if</span> (bundle.dependencies != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; bundle.dependencies.Length; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ABundle temp = bundle.dependencies[i];</span><br><span class="line">                        UnLoad(temp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>同样，在加载的时候，要确保打包没有循环依赖即可</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ABundle <span class="title">LoadInternal</span>(<span class="params"><span class="built_in">string</span> url, <span class="built_in">bool</span> <span class="keyword">async</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ABundle bundle;</span><br><span class="line">    <span class="keyword">if</span> (m_BundleDic.TryGetValue(url, <span class="keyword">out</span> bundle))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bundle.reference == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_NeedUnloadList.Remove(bundle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从缓存中取并引用+1</span></span><br><span class="line">        bundle.AddReference();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bundle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建ab</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">async</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        bundle = <span class="keyword">new</span> BundleAsync();</span><br><span class="line">        bundle.url = url;</span><br><span class="line">        m_AsyncList.Add(bundle <span class="keyword">as</span> ABundleAsync);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">        bundle.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_BundleDic.Add(url, bundle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载依赖</span></span><br><span class="line">    <span class="built_in">string</span>[] dependencies = m_AssetBundleManifest.GetDirectDependencies(url);</span><br><span class="line">    <span class="keyword">if</span> (dependencies.Length &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        bundle.dependencies = <span class="keyword">new</span> ABundle[dependencies.Length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; dependencies.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> dependencyUrl = dependencies[i];</span><br><span class="line">            ABundle dependencyBundle = LoadInternal(dependencyUrl, <span class="keyword">async</span>);</span><br><span class="line">            bundle.dependencies[i] = dependencyBundle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bundle.AddReference();</span><br><span class="line"></span><br><span class="line">    bundle.Load();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bundle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>U3D</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity UGUI框架实战</title>
    <url>/2024/06/02/UI%E6%A1%86%E6%9E%B6%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="UI框架实战"><a href="#UI框架实战" class="headerlink" title="UI框架实战"></a>UI框架实战</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>按理来说，个人开发应该直接找个轮椅用，去大厂大螺丝，应该有现成的用。但这个项目是手搓，最基本的那种，用来熟悉一下框架大概需要实现些什么，也是拖UI的底层基础。</p>
<p>UI框架主要实现UILayer作为基类，分别实现Panel（面板）和Window（窗口、弹窗）层，配套搭配对应的PanelController和WindowController实现逻辑和显示的分离。<span id="more"></span></p>
<p>通过UIFrame对外部暴露统一开启关闭界面等接口，在显示上合理的划分好节点，做好层级遮挡。</p>
<p>对于Window实现队列和栈进行弹出的管理，Panel则不用。</p>
<p>支持界面的传参（Properties类），搭配动画组件和事件系统，形成完整健全的UI框架。</p>
<p>项目地址: <a href="https://github.com/GongQihua">传送门</a>, 演示视频在DEMO文件夹下。</p>
<h2 id="框架的构建和关系"><a href="#框架的构建和关系" class="headerlink" title="框架的构建和关系"></a>框架的构建和关系</h2><p>UIFramework是核心框架，UIFramework example是实现，主要看前者</p>
<p>其中核心类关系大概是：Controller，layer，动画，事件，和一些窗口属性</p>
<p>代码自己看，这里只归纳一下大概的框架结构</p>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>也就是最核心的两个控制器</p>
<p>PanelController（面板）和WindowlController（窗口、弹窗），</p>
<p>WindowlController：带有队列和历史记录，方便管理弹出。</p>
<p>PanelController：则不用记录，主要是用来显示小地图，左上角个人头像之类的面板。</p>
<p>在UIScreenController里定义了基础接口IScreenController，其中被IWindowController和IPanelController两个实现接口所调用</p>
<p><img src="https://s2.loli.net/2024/07/15/rBUnM96DjetcfLV.webp" alt="image1"></p>
<h3 id="Layer"><a href="#Layer" class="headerlink" title="Layer"></a>Layer</h3><p>layer的作用是，在程序跑起来后，管理分层用的</p>
<p>基类是UILayer&lt; TScreen&gt;这个abstract类，扩展为PanelUILayer和WindowUILayer两个类，分别管理面板和窗口的层级</p>
<h3 id="动画类"><a href="#动画类" class="headerlink" title="动画类"></a>动画类</h3><p>基层：AniComponent类</p>
<p>扩展到：</p>
<p>ScaleScreenAni类（缩放比例大小）</p>
<p>SlideScreenAni类（切换，上下左右）</p>
<p>AnimationView类（具体动画实现，封装DoTween之类）</p>
<p>FadeAni（渐入动画）</p>
<h3 id="事件类"><a href="#事件类" class="headerlink" title="事件类"></a>事件类</h3><p>根据具体的逻辑，定义的事件结构</p>
<p><img src="https://s2.loli.net/2024/07/15/ajkvbMyBOJu5xlC.webp" alt="image2"></p>
<p>事件类Signals.cs在External文件夹下，定义了事件处理</p>
<h3 id="窗口属性"><a href="#窗口属性" class="headerlink" title="窗口属性"></a>窗口属性</h3><p>最基本的接口属性类，分Panel和Window两大类</p>
<p>基类IScreenProperties，扩展IPanelProperties和IWindowProperties，面板和窗口</p>
<p>然后WindowProperties类，扩展CameraProjectionWindowProperties，ConfirmationPopupProperties和PlayerWindowProperties三类，在实现文件夹Screencontrollers下</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>U3D</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity莉丽冒险世界</title>
    <url>/2024/07/01/Unity%E5%A5%A5%E5%BE%B7%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="莉丽冒险世界"><a href="#莉丽冒险世界" class="headerlink" title="莉丽冒险世界"></a>莉丽冒险世界</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>项目知识点概况：</p>
<ul>
<li>﻿通过有限状态机实现了人物的动作切换，采用Input System操作玩家。怪物也采用状态机，设计简单的WayPoint类规划巡逻点。</li>
<li>﻿数据存储为二进制，Json，PlayerPrefs三种形式，Serializable游戏数据对象GameData，便于存取。</li>
<li>﻿﻿人物动画为Setlnteger等触发方式，效果融合平滑。实现loading，存档，暂定等UI界面并搭Animation突出效果，用一些协程做效果延迟处理，熟悉特效制作方式。</li>
<li>﻿使用物理系统计算出人物向量速度，设计多种机关障碍物，泳池沼泽，检查点，传送点，导轨台，跳跃台，旗杆等关卡元素，使用碰撞器触发器和一些3D数学计算。</li>
<li>﻿﻿使用常见单例和观察者设计模式，注重逻辑解耦。</li>
</ul>
<p>由于用了状态机，项目庞大，不能向上个文档那样逐步详解了，只能写个各板块功能的概况，额外写一点项目中遇到的知识难点。<span id="more"></span></p>
<h2 id="设计文档"><a href="#设计文档" class="headerlink" title="设计文档"></a>设计文档</h2><p>这部分概述了代码各分块的功能和说明：</p>
<p>核心代码是entity和playstate部分</p>
<p>设计重点就是维护一个有限状态机，PlayerState包含N多状态，玩家一个时刻只能是处于一个状态，方便管理。而除了状态，切换状态也同样重要，例如<code>player.states.Change&lt;IdlePlayerState&gt;();</code></p>
<p>经常使用这个Change。</p>
<p>其余的PlayerStateManager等都是围绕这个状态机来实现的，方便管理用。</p>
<p><strong>这个游戏的核心就是通过合理的架构维护状态机，然后修正玩家的状态，其中最主要的就是垂直和水平两个速度，各种手感都是维护这两个变量而呈现出来的。</strong></p>
<h4 id="1-1-Entity"><a href="#1-1-Entity" class="headerlink" title="1.1. Entity"></a>1.1. Entity</h4><p>Entity是一个抽象类，比如Player和Enemy，你要是扩展新的也是可以的。主要处理移动和碰撞，提供一些基础属性和方法</p>
<h4 id="1-2-EntityEvents"><a href="#1-2-EntityEvents" class="headerlink" title="1.2. EntityEvents"></a>1.2. EntityEvents</h4><p>EntityEvents类定义了由Entity组件触发的所有事件。基础的几个</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> UnityEvent OnGroundEnter;</span><br><span class="line"><span class="keyword">public</span> UnityEvent OnGroundExit;</span><br><span class="line"><span class="keyword">public</span> UnityEvent OnRailsEnter;</span><br><span class="line"><span class="keyword">public</span> UnityEvent OnRailsExit;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-EntityHitbox"><a href="#1-3-EntityHitbox" class="headerlink" title="1.3. EntityHitbox"></a>1.3. EntityHitbox</h4><p>挂在人物身上的，主要是对他人造成伤害或破坏，还允许实体通过反弹来施加伤害以对命中事件做出反应；施加一些力是游戏操作更加丝滑真实。</p>
<h4 id="1-4-EntityState"><a href="#1-4-EntityState" class="headerlink" title="1.4. EntityState"></a>1.4. EntityState</h4><p>所有状态的基类。主要是PlayerState和EnemyState继承的，然后搭配相关的StateManager使用，可以实现更多复杂的状态，以下代码强调子类必须实现这几个接口。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params">T entity</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnExit</span>(<span class="params">T entity</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnStep</span>(<span class="params">T entity</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnContact</span>(<span class="params">T entity, Collider other</span>)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-EntityStateManager"><a href="#1-5-EntityStateManager" class="headerlink" title="1.5. EntityStateManager"></a>1.5. EntityStateManager</h4><p>跟上面是搭配使用的，主要是管理状态的，然后可以切换。动画状态机基本就是这个的可视化，这样理解更加直观一些。</p>
<h4 id="1-6-EntityStateManagerEvents"><a href="#1-6-EntityStateManagerEvents" class="headerlink" title="1.6. EntityStateManagerEvents"></a>1.6. EntityStateManagerEvents</h4><p>核心就这三个事件</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> UnityEvent onChange;</span><br><span class="line"><span class="keyword">public</span> UnityEvent&lt;Type&gt; onEnter;</span><br><span class="line"><span class="keyword">public</span> UnityEvent&lt;Type&gt; onExit;</span><br></pre></td></tr></table></figure>

<p>比如onChange就被PlayerAnimator监听去了，这也就是为什么切换状态的时候人物总是能做对动画，同理怪物的也是。</p>
<h4 id="1-7-EntityStateManagerListener"><a href="#1-7-EntityStateManagerListener" class="headerlink" title="1.7. EntityStateManagerListener"></a>1.7. EntityStateManagerListener</h4><p>维护一个states状态组，当状态进入或者退出的时候，你关心的这个states就可以做一些操作了，这个用在了人物攻击的时候。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params">Type state</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (states.Contains(state.Name))</span><br><span class="line">    &#123;</span><br><span class="line">        onEnter.Invoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-8-EntityStats"><a href="#1-8-EntityStats" class="headerlink" title="1.8. EntityStats"></a>1.8. EntityStats</h4><p>是一个Scriptable脚本记录了所有的状态值，好处是完全可以开放给策划配置，或者说搞一个excel读进来，不过这不是本例子的实现方式。</p>
<h4 id="1-9-EntityStatsManager"><a href="#1-9-EntityStatsManager" class="headerlink" title="1.9. EntityStatsManager"></a>1.9. EntityStatsManager</h4><p>搭配上面使用的</p>
<h4 id="1-10-EntityVolumeEffector"><a href="#1-10-EntityVolumeEffector" class="headerlink" title="1.10. EntityVolumeEffector"></a>1.10. EntityVolumeEffector</h4><p>主要是后期的泥浆Mud用这个，可以很好的处理玩家的缓动速度</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (other.TryGetComponent(<span class="keyword">out</span> Entity entity))</span><br><span class="line">    &#123;</span><br><span class="line">        entity.velocity *= velocityConversion;</span><br><span class="line">        entity.accelerationMultiplier = accelerationMultiplier;</span><br><span class="line">        entity.topSpeedMultiplier = topSpeedMultiplier;</span><br><span class="line">        entity.decelerationMultiplier = decelerationMultiplier;</span><br><span class="line">        entity.turningDragMultiplier = turningDragMultiplier;</span><br><span class="line">        entity.gravityMultiplier = gravityMultiplier;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-11-PlayerInputManager"><a href="#1-11-PlayerInputManager" class="headerlink" title="1.11. PlayerInputManager"></a>1.11. PlayerInputManager</h4><p>这个主要是读取了配置好的操作表，然后专注于写相应逻辑</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> InputAction m_movement;</span><br><span class="line">m_movement = actions[<span class="string">&quot;Movement&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> Vector3 <span class="title">GetMovementDirection</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Time.time &lt; m_movementDirectionUnlockTime) <span class="keyword">return</span> Vector3.zero;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">value</span> = m_movement.ReadValue&lt;Vector2&gt;();</span><br><span class="line">    <span class="keyword">return</span> GetAxisWithCrossDeadZone(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-12-玩家各个状态"><a href="#1-12-玩家各个状态" class="headerlink" title="1.12. 玩家各个状态"></a>1.12. 玩家各个状态</h4><p>在playstate里，直白的命名了，用来给状态机来调用。</p>
<h2 id="项目涉及"><a href="#项目涉及" class="headerlink" title="项目涉及"></a>项目涉及</h2><ol>
<li>有限状态机<ol>
<li>一个时刻只处于一个状态</li>
<li>切换条件判定</li>
</ol>
</li>
<li>输入系统<ol>
<li>Input System</li>
</ol>
</li>
<li>序列化存储<ol>
<li>二进制</li>
<li>json</li>
<li>PlayerPrefs</li>
</ol>
</li>
<li>UGUI<ol>
<li>基础设计</li>
<li>UI动画</li>
<li>基础优化</li>
<li>核心组件</li>
</ol>
</li>
<li>动画切换<ol>
<li>切换方式</li>
<li>切换阀值</li>
<li>优化点</li>
</ol>
</li>
<li>物理计算<ol>
<li>碰撞和触发</li>
<li>3D计算</li>
<li>刚体</li>
</ol>
</li>
<li>设计模式<ol>
<li>单例模式</li>
<li>观察者模式</li>
</ol>
</li>
<li>特效制作<ol>
<li>简单实用</li>
<li>优化点</li>
<li>UIPraticle</li>
</ol>
</li>
<li>协程<ol>
<li>基本原理</li>
<li>线程区别</li>
<li>应用场景</li>
</ol>
</li>
<li>怪物巡逻<ol>
<li>点序列检测计算</li>
<li>怪物状态机</li>
</ol>
</li>
<li>摄像机控制<ol>
<li>插件使用</li>
<li>穿墙设置</li>
</ol>
</li>
</ol>
<p>项目地址: <a href="https://github.com/GongQihua">传送门</a>, 演示视频在DEMO文件夹下。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>U3D</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity指尖赛车</title>
    <url>/2024/05/02/Unity%E6%97%A0%E5%B0%BD%E5%B0%8F%E8%BD%A6/</url>
    <content><![CDATA[<h1 id="指尖赛车"><a href="#指尖赛车" class="headerlink" title="指尖赛车"></a>指尖赛车</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Unity 3D无尽小车项目基本点</p>
<ul>
<li>使用Collider，Rigidbody等物理组件，能做出简单的物理模拟。</li>
<li>根据柏林噪声自动生成地形，可以无限不重复的进行下去。地图采用了2个圆柱地形轮换，属于小型内存池，节省内存空间</li>
<li>使用UGUI制作游戏界面，使用和制作Animation，并且用状态机播放动画。</li>
<li>使用声音和粒子特效增强游戏效果，可以制作简单粒子特效。</li>
</ul>
<p>该项目主要学习内容在于代码生产地形地图的运用，资源包已经扒好了<span id="more"></span></p>
<p>项目地址: <a href="https://github.com/GongQihua/3DRaceCar">传送门</a>, 演示视频在DEMO文件夹下。</p>
<h2 id="小车主体"><a href="#小车主体" class="headerlink" title="小车主体"></a>小车主体</h2><h3 id="拼装小车模型"><a href="#拼装小车模型" class="headerlink" title="拼装小车模型"></a>拼装小车模型</h3><p>车身主题，设置为刚体，不整车设置为碰撞体，设置前保险杠，车身和车顶三个碰撞体</p>
<p>子类里放汽车网格，往上拖材质，车轮的网格和车身的分开，在设置轮胎的碰撞器</p>
<p>车身特效也挂在车身下，meshfliter和render是成对使用的。</p>
<p>汽车使用Unity的内置车轮碰撞器进行悬架物理模拟，网格是分开的。因此汽车很容易更换。</p>
<p>有Wheel Colliders、Car Meshes和Body Colliders将所有对象都放在单独的父对象下。要更改汽车，最好简单地更换Wheel Mesh和Car Mesh。对于Wheel Meshes，在将它们分配给汽车脚本时一定要确保数组保持相同的顺序，以便它们正确地对应于Wheel Colliders。Body Mesh只要摆正位置就可以了。</p>
<p>这些碰撞器根据实际网格调整大小，无论何时如果你改变了轮胎尺寸或车身尺寸，请确保添加新的碰撞器或重新调整现有的来匹配汽车。另外请注意前面的碰撞盒。这个盒子应该保持汽车稳定，以防它撞到汽车的前端。此外，车顶的大圆形对撞器是一个触发器，当汽车翻转时，它就会被触发。这样，当汽车失去平衡并翻倒时，我们就可以停止游戏。</p>
<h3 id="小车代码"><a href="#小车代码" class="headerlink" title="小车代码"></a>小车代码</h3><p>主要部分：控制方向，和模拟轮子向前转</p>
<p>写了一个检测键盘还是鼠标控制的程序在lateupdate里，主要函数：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LateUpdate</span>()</span>&#123;</span><br><span class="line">	<span class="comment">//for all wheels</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; wheelMeshes.Length; i++)&#123;	</span><br><span class="line">		<span class="comment">//set the wheel mesh to the position of the wheel collider</span></span><br><span class="line">		Quaternion quat;</span><br><span class="line">		Vector3 pos;</span><br><span class="line">		</span><br><span class="line">		wheelColliders[i].GetWorldPose(<span class="keyword">out</span> pos, <span class="keyword">out</span> quat);</span><br><span class="line">		</span><br><span class="line">		wheelMeshes[i].position = pos;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//rotate the wheel</span></span><br><span class="line">		wheelMeshes[i].Rotate(Vector3.right * Time.deltaTime * wheelRotateSpeed);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(Input.GetMouseButton(<span class="number">0</span>) || Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">		UpdateTargetRotation();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(targetRotation != <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">//rotate back to the center</span></span><br><span class="line">		targetRotation = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//apply the rotation by rotating towards the target angle on the y axis</span></span><br><span class="line">	Vector3 rotation = <span class="keyword">new</span> Vector3(transform.localEulerAngles.x, targetRotation, transform.localEulerAngles.z);</span><br><span class="line">	transform.rotation = Quaternion.RotateTowards(transform.rotation, Quaternion.Euler(rotation), rotateSpeed * Time.deltaTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateTargetRotation</span>()</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">//get the mouse position</span></span><br><span class="line">		<span class="keyword">if</span>(Input.mousePosition.x &gt; Screen.width * <span class="number">0.5f</span>)&#123;</span><br><span class="line">			<span class="comment">//rotate right</span></span><br><span class="line">			targetRotation = rotationAngle;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//rotate left</span></span><br><span class="line">			targetRotation = -rotationAngle;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		targetRotation = (<span class="built_in">int</span>)(rotationAngle * Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用碰撞器位置，设置轮子网格位置。</p>
<p>车是在原地不动的，地图向着车动，角度变化用的欧拉角</p>
<p>小车防止乱反转记得锁定一下轴翻转</p>
<h2 id="地图生成"><a href="#地图生成" class="headerlink" title="地图生成"></a>地图生成</h2><h3 id="柏林噪声"><a href="#柏林噪声" class="headerlink" title="柏林噪声"></a>柏林噪声</h3><p>因为地形要求平滑，随机生成点的地图上下会乱跳，这个项目里用的柏林噪声平滑曲线</p>
<p>柏林噪声专门针对地形生成的，可以去查一下，核心就是要能”平滑地“生成随机数。</p>
<p>简而言之，我们如果用一个随机数附近几个数的平均值，来替换当前这个值，那么我们得到的随机数则会变得平滑。另外还有一种做法，就是对一维白噪声进行插值，来让它变得平滑。但是，无论是滑动平均数，还是插值，得到的”平滑噪声“都有一个小缺陷：有极大可能，一些地方起伏过高，而一些地方起伏平缓。这样的“山”，依然有一种”突兀感“。怎么办呢？如果我们平滑或者插值的是噪声的“梯度”，也就是高度变化的速率，相当于给平滑的噪声先乘了一个系数，再做了一下积分，那么“突兀”的效果就再次被减小了。这就是柏林噪声的核心原理。</p>
<p>生成两条line直观对比一下效果</p>
<p>测试代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestPerlin</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> LineRenderer _lineRenderer;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> _a = <span class="number">0.86f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> UsePerLin;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _lineRenderer = GetComponent&lt;LineRenderer&gt;();</span><br><span class="line">        Vector3[] posArr = <span class="keyword">new</span> Vector3[<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">float</span> ranx = Random.Range(<span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">float</span> rany = Random.Range(<span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; posArr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (UsePerLin)</span><br><span class="line">            &#123;</span><br><span class="line">                posArr[i] = <span class="keyword">new</span> Vector3(i * <span class="number">0.1f</span>, Mathf.PerlinNoise(i*_a + ranx, i*_a + rany), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                posArr[i] = <span class="keyword">new</span> Vector3(i * <span class="number">0.1f</span>, Random.<span class="keyword">value</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _lineRenderer.SetPositions(posArr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生成地形"><a href="#生成地形" class="headerlink" title="生成地形"></a>生成地形</h3><p>具体代码移步文件 WorldGenerator.cs</p>
<p>Mesh：是指模型的网格，Mesh的主要属性内容包括顶点坐标，法线，纹理坐标，三角形绘制序列等其他有用属性和功能。因此建网格，就是画三角形；画三角形就是定位三个点。<br>Mesh Filter：内包含一个Mesh组件，可以根据MeshFilter获得模型网格的组件，也可以为MeshFilter设置Mesh内容。<br>Mesh Render：是用于把网格渲染出来的组件。MeshFilter的作用就是把Mesh扔给MeshRender将模型或者说是几何体绘制显示出来。</p>
<p><strong>地图</strong></p>
<p>最主要的是scale和dimensions共同决定了地形的大小和细节。Scale就是单个顶点的距离,dimensions表示构成三角形的数量。共同作用生成Mesh。比如将默认scale从0.8更改为1.6,并将x dimensions设置为18而不是32,网格将它们看起来大多一样,只是细节更少。这背后的原因是,在3d空间中增加一半的点,但将其分散到两倍的距离,从而得到相同的大小。</p>
<p>另一个重要值是perlin scale。可以调整这个值来调整粗糙度。地形例如,减小该值将使地形变得平滑,而<br>增加该值会使地形越粗糙,使得控制汽车变得更加困难。还可以设置wave height。将控制隧道内草丘的高度。较小的值使驾驶更平稳,而更高的值将使山丘更大,驾驶更困难。</p>
<p>然后是offset偏移值,这个主要是控制地形的形状的。每次一样的话,将会生成同样的地形。结合<br>randomness随机地形,这个值越大当前生成的与之前的差距就越明显,反之就小。</p>
<p><strong>程序地形生成</strong></p>
<ul>
<li>首先生成了一个三角形。只需要创建一个新的网格和在三角形数组中添加三个顶点（每个角一个）和三个索引以引用我们的顶点。</li>
<li>array（三个新角）我们可以添加另一个三角形并创建一个正方形</li>
<li>接下来，使用两个for循环，从正方形连起来生成了一个完整的平面</li>
<li>最后对于圆柱体，平面需要被包裹成新的形状在顶点上使用余弦和正弦</li>
</ul>
<p>对应了最重要的那个函数 CreateShape，注释都写好了，自己看吧</p>
<h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><p>其实是地图移动，而不是小车移动，让地图向着小车移动，方便无尽拼接地图，主要就是一行代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">transform.Translate(Vector3.forward * movespeed * Time.deltaTime);</span><br></pre></td></tr></table></figure>

<p>别忘了挂上脚本，在worldGenerate代码里挂上（AddComponent）</p>
<p>要给灯光也挂上这个脚本，不然地形走了，灯光没跟上😂</p>
<p>控制镜头写在后面</p>
<h3 id="无尽地形"><a href="#无尽地形" class="headerlink" title="无尽地形"></a>无尽地形</h3><p>上面生成的圆柱体只是一段，走完就没了，要达成无尽的效果，这里用的方法是，两段圆柱互相拼接的方法，走完的地图摧毁掉，重新生成拼接在后面</p>
<p>方法就是生成两个地形，先走一再走二，走二的时候销毁一接到二后面，写在start里</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span>&#123;</span><br><span class="line">		beginPoints = <span class="keyword">new</span> Vector3[(<span class="built_in">int</span>)dimensions.x + <span class="number">1</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//start by generating two world pieces</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">			GenerateWorldPiece(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>用一个数组收集生成的地图块，方便切换</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GenerateWorldPiece</span>(<span class="params"><span class="built_in">int</span> i</span>)</span>&#123;</span><br><span class="line">		<span class="comment">//create a new cylinder and put it in the pieces array</span></span><br><span class="line">		pieces[i] = CreateCylinder();</span><br><span class="line">		<span class="comment">//position the cylinder according to its index</span></span><br><span class="line">		pieces[i].transform.Translate(Vector3.forward * (dimensions.y * scale * Mathf.PI) * i);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//update this piece so it will have an endpoint and it will move etc.</span></span><br><span class="line">		UpdateSinglePiece(pieces[i]);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>然后标记尾部位置，因为我们需要知道一个地图什么时候走完了，地形移动也挂载在这个函数下</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateSinglePiece</span>(<span class="params">GameObject piece</span>)</span>&#123;</span><br><span class="line">		<span class="comment">//add the basic movement script to our newly generated piece to make it move towards the player</span></span><br><span class="line">		BasicMovement movement = piece.AddComponent&lt;BasicMovement&gt;();</span><br><span class="line">		<span class="comment">//make it move with a speed of globalspeed</span></span><br><span class="line">		movement.movespeed = -globalSpeed;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//set the rotate speed to the lamp (directional light) rotate speed </span></span><br><span class="line">		<span class="keyword">if</span>(lampMovement != <span class="literal">null</span>)</span><br><span class="line">			movement.rotateSpeed = lampMovement.rotateSpeed;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//create an endpoint for this piece</span></span><br><span class="line">		GameObject endPoint = <span class="keyword">new</span> GameObject();</span><br><span class="line">		endPoint.transform.position = piece.transform.position + Vector3.forward * (dimensions.y * scale * Mathf.PI);</span><br><span class="line">		endPoint.transform.parent = piece.transform;</span><br><span class="line">		endPoint.name = <span class="string">&quot;End Point&quot;</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//change the perlin noise offset to make sure each piece is different from the last one</span></span><br><span class="line">		offset += randomness;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//change the obstacle chance which means there will be more obstacles over time</span></span><br><span class="line">		<span class="keyword">if</span>(startObstacleChance &gt; <span class="number">5</span>)</span><br><span class="line">			startObstacleChance -= obstacleChanceAcceleration;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>更新地形，循环拼接地图，异步更新运算，写在Lateupdate里</p>
<p>首先，异步地图点检测，拼接替换：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">UpdateWorldPieces</span>()</span>&#123;</span><br><span class="line">		<span class="comment">//remove the first piece (that is not visible to the player anymore)</span></span><br><span class="line">		Destroy(pieces[<span class="number">0</span>]);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//assign the second piece to the first piece in the world array</span></span><br><span class="line">		pieces[<span class="number">0</span>] = pieces[<span class="number">1</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//new create a new second piece</span></span><br><span class="line">		pieces[<span class="number">1</span>] = CreateCylinder();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//position the new piece and rotate it to match the first piece</span></span><br><span class="line">		pieces[<span class="number">1</span>].transform.position = pieces[<span class="number">0</span>].transform.position + Vector3.forward * (dimensions.y * scale * Mathf.PI);</span><br><span class="line">		pieces[<span class="number">1</span>].transform.rotation = pieces[<span class="number">0</span>].transform.rotation;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//update this newly generated world piece</span></span><br><span class="line">		UpdateSinglePiece(pieces[<span class="number">1</span>]);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//wait a frame</span></span><br><span class="line">		<span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>然后实时更新地图</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LateUpdate</span>()</span>&#123;</span><br><span class="line">		<span class="comment">//if the second piece is close enough to the player, we can remove the first piece and update the terrain</span></span><br><span class="line">		<span class="keyword">if</span>(pieces[<span class="number">1</span>] &amp;&amp; pieces[<span class="number">1</span>].transform.position.z &lt;= <span class="number">0</span>)</span><br><span class="line">			StartCoroutine(UpdateWorldPieces());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//update all items in the scene like spikes and gates</span></span><br><span class="line">		UpdateAllItems();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">UpdateAllItems</span>()</span>&#123;</span><br><span class="line">		<span class="comment">//find all items</span></span><br><span class="line">		GameObject[] items = GameObject.FindGameObjectsWithTag(<span class="string">&quot;Item&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//for all items</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; items.Length; i++)&#123;</span><br><span class="line">			<span class="comment">//get all meshrenderers of this item</span></span><br><span class="line">			<span class="keyword">foreach</span>(MeshRenderer renderer <span class="keyword">in</span> items[i].GetComponentsInChildren&lt;MeshRenderer&gt;())&#123;</span><br><span class="line">				<span class="comment">//show this item if it&#x27;s sufficiently close to the player</span></span><br><span class="line">				<span class="built_in">bool</span> show = items[i].transform.position.z &lt; showItemDistance;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span>(show)</span><br><span class="line">					renderer.shadowCastingMode = (items[i].transform.position.y &lt; shadowHeight) ? ShadowCastingMode.On : ShadowCastingMode.Off;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//only enable the renderer if we want to show this item</span></span><br><span class="line">				renderer.enabled = show;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>但是仔细看的时候，会发现地图连接处有空白，两个地图能看出明显的切换</p>
<p>所以这里要优化一下，首先记录一下开始的点beginpoint，然后随机一点柏林噪声生成的图，y &#x3D; kx+b，b随机，最后把判断点后移，让两段地图重叠一段，不要跑过了地图一立即切换</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(z &lt; startTransitionLength &amp;&amp; beginPoints[<span class="number">0</span>] != Vector3.zero)&#123;</span><br><span class="line">					<span class="comment">//if so, we must combine the perlin noise value with the begin points</span></span><br><span class="line">					<span class="comment">//we need to increase the percentage of the vertice that comes from the perlin noise </span></span><br><span class="line">					<span class="comment">//and decrease the percentage from the begin point</span></span><br><span class="line">					<span class="comment">//this way it will transition from the last world piece to the new perlin noise values</span></span><br><span class="line">					</span><br><span class="line">					<span class="comment">//the percentage of perlin noise in the vertices will increase while we&#x27;re moving further into the cylinder</span></span><br><span class="line">					<span class="built_in">float</span> perlinPercentage = z * (<span class="number">1f</span>/startTransitionLength);</span><br><span class="line">					<span class="comment">//don&#x27;t use the z begin point since it will not have the correct position and we only care about the noise on x and y axis</span></span><br><span class="line">					Vector3 beginPoint = <span class="keyword">new</span> Vector3(beginPoints[x].x, beginPoints[x].y, vertices[index].z);</span><br><span class="line">					</span><br><span class="line">					<span class="comment">//combine the begin point(which are the last vertices from the previous world piece) and original vertice to smoothly transition to the new world piece</span></span><br><span class="line">					vertices[index] = (perlinPercentage * vertices[index]) + ((<span class="number">1f</span> - perlinPercentage) * beginPoint);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(z == zCount)&#123;</span><br><span class="line">					<span class="comment">//it these are the last vertices, update the begin points so the next piece will transition smoothly as well</span></span><br><span class="line">					beginPoints[x] = vertices[index];</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<h2 id="相机跟随"><a href="#相机跟随" class="headerlink" title="相机跟随"></a>相机跟随</h2><p>首先，防止乱翻，冻结一下角度，position freeze x和z，rotation freeze y和z，车基本能正常跑了</p>
<p>然后编写相机跟随脚本CameraFollow</p>
<p>upate里监听鼠标事件</p>
<p>Lateupdate里更新视角，算高度和角度，用欧拉角计算，相机跟随脚本：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LateUpdate</span>()</span>&#123;		</span><br><span class="line">		<span class="comment">//Check if the camera has a target to follow</span></span><br><span class="line">        <span class="keyword">if</span>(!camTarget)</span><br><span class="line">            <span class="keyword">return</span>;		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//Some private variables for the rotation and position of the camera</span></span><br><span class="line">        <span class="built_in">float</span> wantedRotationAngle = camTarget.eulerAngles.y;</span><br><span class="line">        <span class="built_in">float</span> wantedHeight = camTarget.position.y + height;</span><br><span class="line">        <span class="built_in">float</span> currentRotationAngle = transform.eulerAngles.y;</span><br><span class="line">        <span class="built_in">float</span> currentHeight = transform.position.y;</span><br><span class="line">		</span><br><span class="line">        currentRotationAngle = Mathf.LerpAngle(currentRotationAngle, wantedRotationAngle, rotationDamping * Time.deltaTime);</span><br><span class="line"> </span><br><span class="line">        currentHeight = Mathf.Lerp(currentHeight, wantedHeight, heightDamping * Time.deltaTime);</span><br><span class="line"> </span><br><span class="line">        Quaternion currentRotation = Quaternion.Euler(<span class="number">0</span>, currentRotationAngle, <span class="number">0</span>);</span><br><span class="line">     </span><br><span class="line">        transform.position = camTarget.position;</span><br><span class="line">        transform.position -= currentRotation * Vector3.forward * distance;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//Set camera postition</span></span><br><span class="line">        transform.position = <span class="keyword">new</span> Vector3(transform.position.x, currentHeight, transform.position.z);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//Look at the camera target</span></span><br><span class="line">        transform.LookAt(camTarget);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加粒子效果"><a href="#添加粒子效果" class="headerlink" title="添加粒子效果"></a>添加粒子效果</h2><p>增加粒子和打滑效果，把组件partical system拖上去，添加材质粒子，调整一下角度大小</p>
<p>在轮子底部再创建一个打滑的印记object，打滑效果脚本实现，写一个协程</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">SkidMark</span>()</span>&#123;</span><br><span class="line">		<span class="comment">//loops continuesly</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">			<span class="comment">//wait for the delay in between individual skid marks</span></span><br><span class="line">			<span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">skidMarkDelay</span>)</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//show skidmarks if we need skidmarks now</span></span><br><span class="line">			<span class="keyword">if</span>(skidMarkRoutine)&#123;</span><br><span class="line">				<span class="comment">//for both rear wheels, instantiate a skid mark and parent it to the environment so it moves realistically</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; skidMarkPivots.Length; i++)&#123;</span><br><span class="line">					GameObject newskidMark = Instantiate(skidMark, skidMarkPivots[i].position, skidMarkPivots[i].rotation);</span><br><span class="line">					newskidMark.transform.parent = generator.GetWorldPiece();</span><br><span class="line">					newskidMark.transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>) * skidMarkSize;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在小车添加代码，更新车轮痕迹和粒子特效，由于是物理的，要写在fixUpdate里</p>
<p>检测轮子是不是在地上，用Physics.Raycast射线的办法，轮子在地上再出痕迹，顺便加个力稳定一下车子</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateEffects</span>()</span>&#123;</span><br><span class="line">		<span class="comment">//if both wheels are off the ground, add force will be true</span></span><br><span class="line">		<span class="built_in">bool</span> addForce = <span class="literal">true</span>;</span><br><span class="line">		<span class="comment">//check if we rotated the car since last frame</span></span><br><span class="line">		<span class="built_in">bool</span> rotated = Mathf.Abs(lastRotation - transform.localEulerAngles.y) &gt; minRotationDifference;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//for both grass effects (rear wheels)</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">			<span class="comment">//get the rear wheels (one of them in each iteration)</span></span><br><span class="line">			Transform wheelMesh = wheelMeshes[i + <span class="number">2</span>];</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//check if this wheel is grounded currently</span></span><br><span class="line">			<span class="keyword">if</span>(Physics.Raycast(wheelMesh.position, Vector3.down, grassEffectOffset * <span class="number">1.5f</span>))&#123;</span><br><span class="line">				<span class="comment">//if so, show the grass effect</span></span><br><span class="line">				<span class="keyword">if</span>(!grassEffects[i].gameObject.activeSelf)</span><br><span class="line">					grassEffects[i].gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//update the grass effect height and the skidmark height to match this wheel</span></span><br><span class="line">				<span class="built_in">float</span> effectHeight = wheelMesh.position.y - grassEffectOffset;</span><br><span class="line">				Vector3 targetPosition = <span class="keyword">new</span> Vector3(grassEffects[i].position.x, effectHeight, wheelMesh.position.z);</span><br><span class="line">				grassEffects[i].position = targetPosition;</span><br><span class="line">				skidMarkPivots[i].position = targetPosition;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//this wheel is grounded so we don&#x27;t need any extra force at the back of the car</span></span><br><span class="line">				addForce = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(grassEffects[i].gameObject.activeSelf)&#123;</span><br><span class="line">				<span class="comment">//if we&#x27;re not grounded, don&#x27;t show the grass effect</span></span><br><span class="line">				grassEffects[i].gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//add force at the back of the car for stabilization</span></span><br><span class="line">		<span class="keyword">if</span>(addForce)&#123;</span><br><span class="line">			rb.AddForceAtPosition(back.position, Vector3.down * constantBackForce);</span><br><span class="line">			<span class="comment">//don&#x27;t show the skidmarks</span></span><br><span class="line">			skidMarkRoutine = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(targetRotation != <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="comment">//if the car has rotated show the skid mark</span></span><br><span class="line">				<span class="keyword">if</span>(rotated &amp;&amp; !skidMarkRoutine)&#123;</span><br><span class="line">					skidMarkRoutine = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(!rotated &amp;&amp; skidMarkRoutine)&#123;</span><br><span class="line">					skidMarkRoutine = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="comment">//don&#x27;t show the skidmark if we&#x27;re rotating back to the center</span></span><br><span class="line">				skidMarkRoutine = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//update the last rotation (which is now the current rotation since everything has been updated)</span></span><br><span class="line">		lastRotation = transform.localEulerAngles.y;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="障碍物和门"><a href="#障碍物和门" class="headerlink" title="障碍物和门"></a>障碍物和门</h2><p>游戏目前由两个项目组成，即钉刺障碍和玩家应该通过的大门。通过驾驶来获得积分。设置任何障碍所需的主要组件是以下内容：</p>
<ul>
<li>﻿﻿障碍物应具有collider</li>
<li>﻿﻿障碍物应具有障碍物脚本</li>
<li>﻿﻿障碍标记tag为“item</li>
</ul>
<p>此外，请确保障碍物的起点位于底部中心，以便将其定位在正确地驶上地形</p>
<p>创建障碍后将其添加到 prefabs 文件夹中，并将新预制件添加到world generator中的obstacles数组中。</p>
<p>除了障碍物，还有gate来得分。为了得分，门有一个额外的collider，这是一个非常小的碰撞盒，is trigger选上。重要的就是请确保正确将触发器放在中心，并尽可能小，这样当我们击中门本身时就不会触发它</p>
<p>脚本写在WorldGenerate里</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateItem</span>(<span class="params">Vector3 vert, <span class="built_in">int</span> x</span>)</span>&#123;</span><br><span class="line">		<span class="comment">//get the center of the cylinder but use the z value from the vertice</span></span><br><span class="line">		Vector3 zCenter = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, vert.z);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//check if we get a correct angle between the center and the vertice</span></span><br><span class="line">		<span class="keyword">if</span>(zCenter - vert == Vector3.zero || x == (<span class="built_in">int</span>)dimensions.x/<span class="number">4</span> || x == (<span class="built_in">int</span>)dimensions.x/<span class="number">4</span> * <span class="number">3</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//create a new item with a small chance of being a gate (gateChance) and a big chance of being an obstacle</span></span><br><span class="line">		GameObject newItem = Instantiate((Random.Range(<span class="number">0</span>, gateChance) == <span class="number">0</span>) ? gate : obstacles[Random.Range(<span class="number">0</span>, obstacles.Length)]);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//rotate the item inwards towards the center position</span></span><br><span class="line">		newItem.transform.rotation = Quaternion.LookRotation(zCenter - vert, Vector3.up);</span><br><span class="line">		<span class="comment">//position the item at the vertice position</span></span><br><span class="line">		newItem.transform.position = vert;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//parent the new item to the current cylinder so it will move and rotate along</span></span><br><span class="line">		newItem.transform.SetParent(currentCylinder.transform, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>最后记得调整一下障碍物和门的朝向</p>
<h2 id="创建UI界面"><a href="#创建UI界面" class="headerlink" title="创建UI界面"></a>创建UI界面</h2><h3 id="主游戏里的界面"><a href="#主游戏里的界面" class="headerlink" title="主游戏里的界面"></a>主游戏里的界面</h3><p>创建一个GameManager对象，然后创一个canvas，canvas下再创个文本，ui自己拖一下吧</p>
<p>文本写上分数和时间，脚本写一个穿过门的加分逻辑，外加gameover界面，自己拖一下</p>
<p>gameover还要停止车所有行动</p>
<p>用PlayerPrefs小型数据库存储得分</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetScore</span>()</span>&#123;</span><br><span class="line">	<span class="comment">//update the highscore if our score is higher then the previous best score</span></span><br><span class="line">	<span class="keyword">if</span>(score &gt; PlayerPrefs.GetInt(<span class="string">&quot;best&quot;</span>))</span><br><span class="line">		PlayerPrefs.SetInt(<span class="string">&quot;best&quot;</span>, score);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//show the score and the high score</span></span><br><span class="line">	gameOverScoreLabel.text = <span class="string">&quot;score: &quot;</span> + score;</span><br><span class="line">	gameOverBestLabel.text = <span class="string">&quot;best: &quot;</span> + PlayerPrefs.GetInt(<span class="string">&quot;best&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另在障碍物的代码里，加入撞到障碍物，就调出gamemanager的界面</p>
<h3 id="结束界面和动画"><a href="#结束界面和动画" class="headerlink" title="结束界面和动画"></a>结束界面和动画</h3><p>创一个canvas，做结束界面，上面想要什么可以加，这里只做了最基本的</p>
<p>设一个动画，飞入，哈哈，附上脚本，播放</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GameOver</span>()</span>&#123;</span><br><span class="line">	<span class="comment">//the game cannot be over multiple times so we need to return if the game was over already</span></span><br><span class="line">	<span class="keyword">if</span>(gameOver)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//update the score and highscore</span></span><br><span class="line">	SetScore();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//show the game over animation and play the audio</span></span><br><span class="line">	gameOverAnimator.SetTrigger(<span class="string">&quot;Game over&quot;</span>);</span><br><span class="line">	gameOverAudio.Play();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//the game is over</span></span><br><span class="line">	gameOver = <span class="literal">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//break the car</span></span><br><span class="line">	car.FallApart();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//stop the world from moving or rotating</span></span><br><span class="line">	<span class="keyword">foreach</span>(BasicMovement basicMovement <span class="keyword">in</span> GameObject.FindObjectsOfType&lt;BasicMovement&gt;())&#123;</span><br><span class="line">		basicMovement.movespeed = <span class="number">0</span>;</span><br><span class="line">		basicMovement.rotateSpeed = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另添加一个小车碰到障碍物撞毁的脚本在car里，资源prefab已经有了</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FallApart</span>()</span>&#123;</span><br><span class="line">	<span class="comment">//destroy the car</span></span><br><span class="line">	Instantiate(ragdoll, transform.position, transform.rotation);</span><br><span class="line">	gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺便，撞到门也要摧毁，包括穿过门加分，脚本写在Gate.cs里</p>
<h3 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h3><p>新创一个主界面scene，作为主界面</p>
<p>background把地图生成代码挂上，看着好看一点</p>
<p>然后写脚本main menu，设置主界面跳转game的scene</p>
<p>用eventsystem判断是否点在ui上</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Return) ||</span><br><span class="line">	    (Input.GetMouseButtonDown(<span class="number">0</span>) &amp;&amp; !EventSystem.current.IsPointerOverGameObject()))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(Input.touchCount &gt; <span class="number">0</span> &amp;&amp; Input.GetTouch(<span class="number">0</span>).phase == TouchPhase.Began &amp;&amp;</span><br><span class="line">		     EventSystem.current.IsPointerOverGameObject((Input.GetTouch(<span class="number">0</span>).fingerId))))</span><br><span class="line">		&#123;</span><br><span class="line">			StartGame();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartGame</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">	UIAnimator.SetTrigger(<span class="string">&quot;Start&quot;</span>);</span><br><span class="line">	StartCoroutine(LoadScene(<span class="string">&quot;Game&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerator <span class="title">LoadScene</span>(<span class="params"><span class="built_in">string</span> scene</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">0.6f</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">	SceneManager.LoadScene(scene);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再简单写个music脚本，持续循环播放，挂上！结束！完结撒花🎉</p>
<blockquote>
<p>第一次写没有教程的项目，可能看着有点乱，脚本思路也是想到哪写到哪，下次注意！</p>
</blockquote>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>U3D</tag>
      </tags>
  </entry>
</search>
